# EmbedPack — README

Version: 1.0.0  
Last updated: 2026-02-09

EmbedPack is a Win32 desktop utility that converts arbitrary files into C/C++ byte array initializers with support for large-file streaming and asynchronous execution.

## Scope

This repository contains a Windows (Win32) GUI utility that converts an input file into a C/C++ byte array initializer.

Primary outputs:
- In-memory text output for small files (intended for UI display / clipboard copy).
- File output for large files (writes a `.cpp`-compatible text file with the generated byte array).

Target environment:
- Windows desktop (Win32 API).
- CMake-based build (MSVC toolchain expected).

## Architecture

### High-level components

- `EmbedPack::App`
  - Win32 application entry and message loop.
  - Owns the main window and UI state.
  - Initiates conversion jobs and receives progress/completion notifications.

- `EmbedPack::CoreServices`
  - Clipboard helper for Unicode text.
  - File dialog helpers (open input file, save output path).
  - Converter subsystem with asynchronous execution.

### Data flow

1. User selects an input file through an Open File dialog.
2. The application chooses a mode:
   - Small mode: generate output as a Unicode string in memory (intended for UI/clipboard).
   - Large mode: stream output into an on-disk file to avoid holding large text in memory.
3. Conversion runs on a worker thread.
4. The worker thread reports progress and completion back to the UI via window messages.

### Concurrency and notifications

The converter runs asynchronously using a dedicated worker thread. UI updates are triggered by posting window messages:
- `WM_APP_PROGRESS`: periodic progress updates (percentage).
- `WM_APP_DONE`: completion notification with a success flag and a result message.

## Threat Model

This section describes operational risks and misuse cases relevant to correctness and reliability. It does not claim security hardening beyond the stated behavior.

### In-scope scenarios

- User provides valid local file paths accessible for read (input) and write (output).
- Files can be empty or arbitrary binary content.
- Output is consumed as source text in C/C++ projects.

### Out-of-scope scenarios

- Files exceeding what the current process can map or address (e.g., exceeding `size_t` limits).
- Network shares or special filesystem semantics that prevent file mapping or stable reads.
- Guaranteeing that generated output compiles under every compiler configuration or style guide (format is a conventional `const unsigned char[]` initializer plus a `size_t` length).

### Failure modes handled

- Input file cannot be opened (permissions, missing file, locked file).
- File mapping fails (system limitations, access restrictions).
- Output file cannot be created or written (permissions, invalid path).
- Large files are blocked from the in-memory UI path by a soft size limit.

### Residual risks

- Very large conversions can take significant time and generate very large text outputs; large mode mitigates memory growth but output size still scales with input size.
- Conversion performance depends on disk throughput and OS file mapping behavior.
- If the application is terminated during large-mode conversion, the output file may be incomplete.

## Mechanisms / Implementation

### Conversion format

Large mode writes a C/C++ compatible text output:
- Header: `const unsigned char fileBytes[] = {`
- Body: hex bytes formatted as `0xNN` with commas, split into lines.
- Footer:
  - `};`
  - `const size_t fileBytesSize = sizeof(fileBytes);`

Small mode generates the same logical content as a Unicode string in memory, suitable for showing in the UI and copying to the clipboard.

### Size handling

- The converter exposes `UI_SOFT_LIMIT = 8 MiB` as the soft threshold for UI (in-memory) generation.
- Files above the UI soft limit are intended to be processed using large mode (file output) to avoid excessive UI memory use.

### I/O strategy

- Input file is opened read-only and mapped into memory via file mapping for efficient access.
- Large-mode output is written incrementally to the output file using an internal buffered approach to avoid holding the entire generated text in memory.
- Progress is reported periodically during large-mode conversion.

## Limitations

### Known limitations

- Windows-only (Win32 API usage).
- Depends on file mapping; environments where mapping is restricted may fail conversions.
- Generated output is plain text and can become very large relative to the input size.

### Out-of-scope attacks / scenarios

- Not designed to defend against malicious local interference (e.g., external process tampering, forced termination, filesystem race conditions).
- Not designed for sandboxed or restricted runtime environments where clipboard or file dialogs are blocked.

### Residual risks

- Large output files can consume significant disk space.
- UI responsiveness depends on message handling and frequency of progress updates; conversion itself runs off the UI thread.

## Performance impact

Performance characteristics depend on:
- Input file size.
- Storage speed (read for input, write for output).
- CPU cost of formatting bytes into hex text.

Large mode is designed to reduce peak memory usage by streaming output rather than building a full in-memory string. Small mode generates a full in-memory Unicode string and is limited by the UI soft limit.

## Build and run

### Prerequisites

- Windows 10/11
- CMake (3.20+ recommended)
- MSVC toolchain (Visual Studio Build Tools or Visual Studio)

### Build with CMake (example)

1. Configure:
   - `cmake -S . -B build -G "Visual Studio 17 2022" -A x64`
2. Build:
   - `cmake --build build --config Release`

### Batch build script

- `build_release.bat` provides a Windows batch entry point for a Release build (see the script for details).

## Project structure

- `CMakeLists.txt`  
  CMake build configuration.

- `build_release.bat`  
  Convenience script for building a Release configuration on Windows.

- `main.cpp`  
  `wWinMain` entry point and application start.

- `App.h`  
  `EmbedPack::App` declaration (Win32 application wrapper).

- `App.cpp`  
  Win32 UI implementation, message loop integration, and job orchestration.

- `CoreServices.h`  
  Public APIs for clipboard, file dialogs, and conversion job interface.

- `CoreServices.cpp`  
  Implementations of clipboard, file dialogs, file sizing, and conversion logic (small in-memory path and large streaming path).

## Change Log

### 1.0.0 — 2026-02-09
- Initial documented version.
- Win32 UI wrapper (`EmbedPack::App`) with asynchronous conversion jobs.
- Converter supports small (in-memory) and large (stream-to-file) output paths with progress reporting.
