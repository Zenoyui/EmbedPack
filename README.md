# EmbedPack â€” README

![License](https://img.shields.io/badge/license-MIT-green)
![Latest Release](https://img.shields.io/github/v/release/Zenoyui/EmbedPack)
![Downloads](https://img.shields.io/github/downloads/Zenoyui/EmbedPack/total)
![Platform](https://img.shields.io/badge/platform-Windows%2010%2B-blue)
![C++](https://img.shields.io/badge/C%2B%2B-17-blue)


Version: 2.0.0
Last updated: 2026-02-09
Project Type: D - Applications (Desktop Application)

EmbedPack is a Win32 desktop utility that converts arbitrary files into C/C++ byte array initializers with support for large-file streaming and asynchronous execution.

## Screenshot

![EmbedPack UI](docs/screenshot2.0.0.png)

## Scope

This repository contains a Windows (Win32) GUI utility that converts an input file into a C/C++ byte array initializer.

Primary outputs:
- In-memory text output for small files (intended for UI display / clipboard copy).
- File output for large files (writes a `.cpp`-compatible text file with the generated byte array).
- Configurable element types and array styles (e.g., `unsigned char`, `uint8_t`, `std::byte`, `uint32_t`, `uint64_t`, and `std::array`/`constexpr` variants).

Target environment:
- Windows desktop (Win32 API).
- CMake-based build (MSVC toolchain expected).

## Architecture

### High-level components

- `EmbedPack::App`
  - Win32 application entry and message loop.
  - Owns the main window and UI state.
  - Initiates conversion jobs, owns format selections (element type + array style), and receives progress/completion notifications.

- `EmbedPack::CoreServices`
  - Clipboard helper for Unicode text.
  - File dialog helpers (open input file, save output path).
  - Converter subsystem with asynchronous execution.

### Data flow

1. User selects an input file through an Open File dialog.
2. The user chooses the desired output element type and array style from the bottom status bar dropdowns.
3. The application chooses a mode:
   - Small mode: generate output as a Unicode string in memory (intended for UI/clipboard).
   - Large mode: stream output into an on-disk file to avoid holding large text in memory.
4. Conversion runs on a worker thread.
5. The worker thread reports progress and completion back to the UI via window messages.

### Concurrency and notifications

The converter runs asynchronously using a dedicated worker thread. UI updates are triggered by posting window messages:
- `WM_APP_PROGRESS`: periodic progress updates (percentage).
- `WM_APP_DONE`: completion notification with a success flag and a result message.

## Runtime Characteristics

### Execution Model

- UI thread: Win32 message loop handles user input and UI updates
- Worker thread: spawned per conversion job for blocking file I/O and byte array generation
- Non-blocking UI: conversion runs asynchronously, UI remains responsive

### Threading Model

- Single UI thread owns all HWND and GDI resources
- Single worker thread per active conversion job
- Thread communication: worker posts WM_APP_PROGRESS and WM_APP_DONE messages to UI thread via PostMessageW
- No shared mutable state between threads (worker receives copy of job parameters)

### State Management

- Stateful: UI maintains current file selection, format settings, output buffer
- State lifetime: persists until new file selected or application closed
- No persistent state on disk (settings reset on restart)

### Memory Allocation Model

- Dynamic allocation: file mapping for input, heap allocation for output buffer (small mode)
- Large mode: output streamed to disk with fixed 8MB buffer to limit memory growth
- Worker thread allocates heap message for completion notification (freed by UI thread)

### Lifecycle Model

- Initialization: OleInitialize, common controls initialization, window creation
- Runtime: user selects file, chooses format, triggers conversion
- Conversion: worker thread spawned, job executed, completion message posted
- Shutdown: worker thread detached (no explicit join), OleUninitialize, window destruction

## System Boundaries

This section defines the boundaries of the system, external dependencies, trust assumptions, and operational scope.

### What is included in the system

- Win32 GUI application (main window, dialogs, message loop)
- File I/O subsystem (file mapping, buffered write for large files)
- Byte array formatter (hex encoding, header/footer generation)
- Format selector (element type, array style configuration)

### External dependencies

- Windows OS: ntdll.dll, kernel32.dll (file mapping, threading)
- User32.dll, Comctl32.dll (UI controls, dialogs)
- MSVC runtime: CRT heap allocator
- Msftedit.dll: RichEdit control for output display

### Trust boundaries

- Assumes trusted local filesystem: no validation of file content beyond size check
- Assumes valid file paths from OpenFileDialog API (no additional path sanitization)
- UI thread trusts worker thread completion message (no authentication of message source)

### External interfaces

- Win32 OpenFileDialog/SaveFileDialog: user file selection
- Windows file mapping API: CreateFileMappingW, MapViewOfFile
- Clipboard API: SetClipboardData for text output
- Worker thread: CreateThread, PostMessageW for completion notification

### In-scope scenarios

- User provides valid local file paths accessible for read (input) and write (output).
- Files can be empty or arbitrary binary content.
- Output is consumed as source text in C/C++ projects.

### Out-of-scope scenarios

- Files exceeding what the current process can map or address (e.g., exceeding `size_t` limits).
- Network shares or special filesystem semantics that prevent file mapping or stable reads.
- Guaranteeing that generated output compiles under every compiler configuration or style guide (format is a conventional `const unsigned char[]` initializer plus a `size_t` length).

### Failure modes handled

- Input file cannot be opened (permissions, missing file, locked file).
- File mapping fails (system limitations, access restrictions).
- Output file cannot be created or written (permissions, invalid path).
- Large files are blocked from the in-memory UI path by a soft size limit.

### Residual risks

- Very large conversions can take significant time and generate very large text outputs; large mode mitigates memory growth but output size still scales with input size.
- Conversion performance depends on disk throughput and OS file mapping behavior.
- If the application is terminated during large-mode conversion, the output file may be incomplete.

## Risk & Failure Model

### Operational Risks

- File mapping limitation: conversion fails if file cannot be mapped (network drives, restricted filesystems)
- Memory exhaustion: small mode limited to UI_SOFT_LIMIT (8MiB) to prevent UI freeze due to excessive memory allocation
- Output size growth: generated text output is 4-6x larger than input size (hex encoding overhead)
- Worker thread termination: if application closed during conversion, worker thread detached (no cleanup of partial output file)

### Failure Scenarios

- Input file locked or inaccessible: conversion aborts with error message "open: fail (path=..., code=...)"
- File mapping failure: conversion aborts, typically due to insufficient virtual address space or permissions
- Output file creation failure: large mode aborts if output path invalid or write permission denied
- Mid-conversion application termination: large mode leaves partial output file on disk (no atomic write)

### Out-of-scope scenarios

- Network filesystem edge cases: SMB/NFS mounts with non-standard file mapping behavior not tested
- Files exceeding size_t limits on 32-bit systems: conversion will fail during size query
- Non-standard file permissions: assumes standard Windows file ACLs
- Compressed/encrypted NTFS files: relies on OS transparent decompression/decryption

### Residual risks

- Large mode partial output: no transactional write, partial file remains if process killed
- Worker thread leak on forced termination: thread handle not joined, relies on OS cleanup
- UI soft limit tuning: 8MiB threshold is heuristic, may need adjustment for low-memory systems

## Mechanisms / Implementation

### Conversion format

Output is C/C++ compatible source text whose element type and container style are user-selectable:

- Element types: `unsigned char`, `uint8_t`, `std::byte`, `unsigned short`, `uint16_t`, `uint32_t`, `uint64_t`.
- Array styles:
  - `const T data[] = { ... };`
  - `static const T data[] = { ... };`
  - `constexpr T data[] = { ... };`
  - `constexpr std::array<T, N> data = { ... };`
  - `static constexpr std::array<T, N> data = { ... };`

Formatting details:
- Bytes are grouped little-endian into the chosen element width (1/2/4/8 bytes). Partial trailing elements are padded with zeros to the nearest element boundary; the original byte length is emitted as `size_t fileBytesOriginalSize` when padding occurs.
- Hex tokens use the minimal necessary width for the chosen element size (at least two hex digits).
- Includes are emitted automatically (`<cstddef>`, `<cstdint>`, `<array>` as needed).
- A `size_t fileBytesSize = sizeof(fileBytes);` companion constant is always emitted.

Small mode generates the same logical content as a Unicode string in memory (intended for UI/clipboard). Large mode streams the identical format to disk.

### Size handling

- The converter exposes `UI_SOFT_LIMIT = 8 MiB` as the soft threshold for UI (in-memory) generation.
- Files above the UI soft limit are intended to be processed using large mode (file output) to avoid excessive UI memory use.
- For element widths greater than 1 byte, the last element may be zero-padded; use `fileBytesOriginalSize` to recover the original byte length.

### I/O strategy

- Input file is opened read-only and mapped into memory via file mapping.
- Large-mode output is written incrementally to the output file using an internal buffered approach to avoid holding the entire generated text in memory.
- Progress is reported periodically during large-mode conversion.

## Limitations

### Known limitations

- Windows-only (Win32 API usage).
- Depends on file mapping; environments where mapping is restricted may fail conversions.
- Generated output is plain text and can become very large relative to the input size.
- Padding for multi-byte element types can introduce extra zeros at the end of `fileBytes`; consumers that require the exact original length should read `fileBytesOriginalSize`.

### Out-of-scope attacks / scenarios

- Not designed to defend against malicious local interference (e.g., external process tampering, forced termination, filesystem race conditions).
- Not designed for sandboxed or restricted runtime environments where clipboard or file dialogs are blocked.

### Residual risks

- Large output files can consume significant disk space.
- UI responsiveness depends on message handling and frequency of progress updates; conversion itself runs off the UI thread.

## Performance impact

Performance characteristics depend on:
- Input file size.
- Storage speed (read for input, write for output).
- CPU cost of formatting bytes into hex text.

Large mode reduces peak memory usage by streaming output rather than building a full in-memory string. Small mode generates a full in-memory Unicode string and is limited by the UI soft limit.

## Build and run

### Prerequisites

- Windows 10/11
- CMake (3.20+ recommended)
- MSVC toolchain (Visual Studio Build Tools or Visual Studio)

### Build with CMake (example)

1. Configure:
   - `cmake -S . -B build -G "Visual Studio 17 2022" -A x64`
2. Build:
   - `cmake --build build --config Release`

### Batch build script

- `build_release.bat` is a Windows batch entry point for a Release build (see the script for details).

## Project structure

- `CMakeLists.txt`  
  CMake build configuration.

- `build_release.bat`  
  Convenience script for building a Release configuration on Windows.

- `main.cpp`  
  `wWinMain` entry point and application start.

- `App.h`  
  `EmbedPack::App` declaration (Win32 application wrapper).

- `App.cpp`  
  Win32 UI implementation, message loop integration, and job orchestration.

- `CoreServices.h`  
  Public APIs for clipboard, file dialogs, and conversion job interface.

- `CoreServices.cpp`  
  Implementations of clipboard, file dialogs, file sizing, and conversion logic (small in-memory path and large streaming path).
